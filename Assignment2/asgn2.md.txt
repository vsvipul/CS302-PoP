# CS302: Paradigms of Programming

## Feb-Jun 2020

Programming Assignment 2: Programming with Streams
==================================================

As we have studied in the class, streams are a lazy data structure that allow us to work efficiently with long or even infinite sequences. Apart from the modular elegance, they also allow us to model the real world in a time-less manner.
In this assignment, we implement an entertaining and instructive two-player game that serves as a concrete illustration of the newly learnt paradigm.

**Plagiarism warning:**

> Note that this assignment is supposed to be done individually; groups and discussions are only for the labs.
> Specifically, you should neither show code to each other nor put it up on web.
> We will be using sophisticated plagiarism checkers and any significant detection will lead to heavy penalization.
> You are free to approach the TAs or the instructor for any queries/doubts.
> Discussions on the mailing list are encouraged.

## Problem: Paper, Rock, Scissors

Recall the simple game called "Paper, Rock, Scissors" that you might have played in your childhood. The game is played in rounds and involves two players.
In each round, each player forms a hand in the shape of either a rock (a clenched fist), a piece of paper (a flat palm), or a pair of scissors (two fingers extended). At a given instant, both players bring their hidden hand forward. The winner is determined by the rule "paper wraps rock, rock blunts scissors, and scissors cut paper".
Thus, in a particular round, if player 1 produces a rock and player 2 produces a pair of scissors, then player 1 wins that round. If both players produce the same object, then the round is a tie. The game continues in this manner for a fixed number of rounds (agreed in advance to avoid cheating!), and the player having won the highest number of rounds wins the game.

### Strategies

Say each player can follow either of the following two strategies:
- *Strategy 1: Simple*. Always produce what the opponent produced in the previous round.
- *Strategy 2: (Over!)Smart*. Find the favorite move of the opponent by analyzing all the moves produced by him/her produced so far, and produce the next move accordingly. For example, if the favorite move of the opponent is found to be "Paper", then this strategy would produce "Scissors" as the next move.

### Assignment

Imagine the sequence of the moves generated by each player as two infinite streams. On the other hand, construct two players such that the strategy chosen by each player is decided before-hand (our players haven't learnt about artificial neural networks yet).
Notice that both the strategies rely on the fact, similar to our 'primes' and 'prime?' example, that though the stream to be examined is infinite, enough of it has been generated to produce the next move.
Your program should consist of a top level function called `play` that takes four inputs: strategy for player one (as a number), strategy for player two (as another number), the first move of player one (as a number), and the number of rounds to simulate. The function `play` should generate a single output: either 1 or 2 indicating the player who won the game, or 0 indicating that there was a tie.
The codes for the first move of the first player are:
- Rock: 1
- Paper: 2
- Scissors: 3
For the second player, assume that the first move is always "Rock", irrespective of the strategy employed.
Further, make sure the two streams are retained in global variables "harry" (player 1) and "voldemort" (player 2) so that we should be able to print a particular element of the streams, if required.

## Submission

- You need to submit a single file named `rollnum-asgn2.scm` (where 'rollnum' is your roll number in small letters) consisting of the function `play`, and the streams `harry` and `voldemort` defined in the global environment.
- Make sure your file contains "#lang sicp" at the top, and that it doesn't depend on any other modules.
- Any other helper functions or variables that you use should be modularized and invisible to the outside world.

## Evaluation

We will be using a testcase-based autmated evaluation to check various standard as well as corner cases. You will get marks based on how many testcases does your submission pass.

